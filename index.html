<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>迷路生成</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <label for="level">レベルを選択:</label>
    <select id="level">
        <option value="1">レベル 1</option>
        <option value="2">レベル 2</option>
        <option value="3">レベル 3</option>
        <option value="4">レベル 4</option>
        <option value="5">レベル 5</option>
    </select>
    <button id="generateMaze">新しい迷路を作る</button>
    <canvas id="mazeCanvas" width="500" height="500"></canvas>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        let cellSize;
        let cols;
        let rows;
        let arrowX = 0;
        let arrowY = 0;
        let arrowInterval;
        let grid = [];
        let visitedCells = new Set();
        let cheese = null;
        const maxYellowCells = 10;
        let highlightMap = {};
        let cheeseCount = 0;

        function generateMaze() {
            const level = parseInt(document.getElementById('level').value);
            cellSize = 100 / level;
            cols = Math.floor(canvas.width / cellSize);
            rows = Math.floor(canvas.height / cellSize);

            grid = [];
            visitedCells = new Set();
            cheese = null;
            highlightMap = {};
            cheeseCount = 0;
            const stack = [];
            let current;

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    grid.push(new Cell(x, y));
                }
            }

            current = grid[0];
            current.visited = true;

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let i = 0; i < grid.length; i++) {
                    grid[i].show();
                }
                if (cheese) {
                    highlightCells(cheese.x, cheese.y);
                    drawCheese(cheese.x, cheese.y);
                }
                drawStartAndGoal();
                drawArrow(arrowX, arrowY);
            }

            function Cell(x, y) {
                this.x = x;
                this.y = y;
                this.walls = [true, true, true, true]; // top, right, bottom, left
                this.visited = false;

                this.show = function() {
                    const x = this.x * cellSize;
                    const y = this.y * cellSize;
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;

                    if (this.walls[0]) ctx.strokeRect(x, y, cellSize, 0); // top
                    if (this.walls[1]) ctx.strokeRect(x + cellSize, y, 0, cellSize); // right
                    if (this.walls[2]) ctx.strokeRect(x, y + cellSize, cellSize, 0); // bottom
                    if (this.walls[3]) ctx.strokeRect(x, y, 0, cellSize); // left

                    if (this.visited) {
                        ctx.fillStyle = 'white';
                        ctx.fillRect(x, y, cellSize, cellSize);
                    }
                };

                this.checkNeighbors = function() {
                    const neighbors = [];
                    const top = grid[index(this.x, this.y - 1)];
                    const right = grid[index(this.x + 1, this.y)];
                    const bottom = grid[index(this.x, this.y + 1)];
                    const left = grid[index(this.x - 1, this.y)];

                    if (top && !top.visited) neighbors.push(top);
                    if (right && !right.visited) neighbors.push(right);
                    if (bottom && !bottom.visited) neighbors.push(bottom);
                    if (left && !left.visited) neighbors.push(left);

                    if (neighbors.length > 0) {
                        const r = Math.floor(Math.random() * neighbors.length);
                        return neighbors[r];
                    } else {
                        return null;
                    }
                };
            }

            function index(x, y) {
                if (x < 0 || y < 0 || x >= cols || y >= rows) {
                    return -1;
                }
                return x + y * cols;
            }

            function removeWalls(a, b) {
                const x = a.x - b.x;
                if (x === 1) {
                    a.walls[3] = false;
                    b.walls[1] = false;
                } else if (x === -1) {
                    a.walls[1] = false;
                    b.walls[3] = false;
                }
                const y = a.y - b.y;
                if (y === 1) {
                    a.walls[0] = false;
                    b.walls[2] = false;
                } else if (y === -1) {
                    a.walls[2] = false;
                    b.walls[0] = false;
                }
            }

            function step() {
                draw();
                const next = current.checkNeighbors();
                if (next) {
                    next.visited = true;
                    stack.push(current);
                    removeWalls(current, next);
                    current = next;
                } else if (stack.length > 0) {
                    current = stack.pop();
                } else {
                    clearInterval(interval);
                    moveArrow();
                }
            }

            function drawStartAndGoal() {
                // startはDrawしない

                // Draw goal
                ctx.fillStyle = 'red';
                ctx.fillRect((cols - 1) * cellSize, (rows - 1) * cellSize, cellSize, cellSize);
            }

            function drawArrow(x, y) {
                const arrowSize = cellSize * 0.6;
                const offsetX = (cellSize - arrowSize) / 2;
                const offsetY = (cellSize - arrowSize) / 2;
                ctx.fillStyle = 'blue';
                ctx.beginPath();
                ctx.moveTo(x * cellSize + offsetX, y * cellSize + offsetY + arrowSize / 2);
                ctx.lineTo(x * cellSize + offsetX + arrowSize, y * cellSize + offsetY + arrowSize / 2);
                ctx.lineTo(x * cellSize + offsetX + arrowSize / 2, y * cellSize + offsetY);
                ctx.closePath();
                ctx.fill();
            }

            function drawCheese(x, y) {
                const cheeseSize = cellSize * 0.6;
                const offsetX = (cellSize - cheeseSize) / 2;
                const offsetY = (cellSize - cheeseSize) / 2;
                ctx.fillStyle = 'rgba(255, 128, 0)';
                ctx.beginPath();
                ctx.moveTo(x * cellSize + offsetX, y * cellSize + offsetY + cheeseSize);
                ctx.lineTo(x * cellSize + offsetX + cheeseSize, y * cellSize + offsetY + cheeseSize);
                ctx.lineTo(x * cellSize + offsetX + cheeseSize / 2, y * cellSize + offsetY);
                ctx.closePath();
                ctx.fill();
            }

            function highlightCells(cx, cy) {
                const queue = [{ x: cx, y: cy, distance: 0 }];
                const visited = new Set();
                visited.add(`${cx},${cy}`);
                highlightMap = {};

                while (queue.length > 0) {
                    const { x, y, distance } = queue.shift();
                    if (distance > maxYellowCells) break;

                    const intensity = (1 - distance / maxYellowCells) * 0.8;
                    ctx.fillStyle = `rgba(255, 255, 0, ${intensity})`;
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    highlightMap[`${x},${y}`] = intensity;

                    const directions = [
                        { dx: 1, dy: 0, wall: 1, oppositeWall: 3 }, // right
                        { dx: 0, dy: 1, wall: 2, oppositeWall: 0 }, // down
                        { dx: -1, dy: 0, wall: 3, oppositeWall: 1 }, // left
                        { dx: 0, dy: -1, wall: 0, oppositeWall: 2 }  // up
                    ];

                    for (const dir of directions) {
                        const newX = x + dir.dx;
                        const newY = y + dir.dy;
                        const currentCell = grid[index(x, y)];
                        const nextCell = grid[index(newX, newY)];

                        if (newX >= 0 && newY >= 0 && newX < cols && newY < rows && !currentCell.walls[dir.wall] && !nextCell.walls[dir.oppositeWall] && !visited.has(`${newX},${newY}`)) {
                            queue.push({ x: newX, y: newY, distance: distance + 1 });
                            visited.add(`${newX},${newY}`);
                        }
                    }
                }
            }

            function moveArrow() {
                const directions = [
                    { dx: 1, dy: 0, wall: 1 }, // right
                    { dx: 0, dy: 1, wall: 2 }, // down
                    { dx: -1, dy: 0, wall: 3 }, // left
                    { dx: 0, dy: -1, wall: 0 }  // up
                ];
                let currentDirection = 0;

                arrowInterval = setInterval(() => {
                    let moved = false;

                    if (cheese && highlightMap[`${arrowX},${arrowY}`]) {
                        let maxIntensity = -1;
                        let nextMove = null;

                        for (const dir of directions) {
                            const newX = arrowX + dir.dx;
                            const newY = arrowY + dir.dy;
                            const currentCell = grid[index(arrowX, arrowY)];
                            const nextCell = grid[index(newX, newY)];

                            if (newX >= 0 && newY >= 0 && newX < cols && newY < rows && !currentCell.walls[dir.wall] && !nextCell.walls[dir.oppositeWall]) {
                                const intensity = highlightMap[`${newX},${newY}`];
                                if (intensity > maxIntensity) {
                                    maxIntensity = intensity;
                                    nextMove = { x: newX, y: newY };
                                }
                            }
                        }

                        if (nextMove) {
                            arrowX = nextMove.x;
                            arrowY = nextMove.y;
                            visitedCells.add(`${arrowX},${arrowY}`);
                            moved = true;
                        }

                        if (arrowX === cheese.x && arrowY === cheese.y) {
                            cheese = null;
                            highlightMap = {};
                        }
                    } else {
                        for (let i = 0; i < directions.length; i++) {
                            const dir = directions[(currentDirection + i) % directions.length];
                            const newX = arrowX + dir.dx;
                            const newY = arrowY + dir.dy;
                            const currentCell = grid[index(arrowX, arrowY)];
                            const nextCell = grid[index(newX, newY)];

                            if (newX >= 0 && newY >= 0 && newX < cols && newY < rows && !currentCell.walls[dir.wall] && !visitedCells.has(`${newX},${newY}`)) {
                                arrowX = newX;
                                arrowY = newY;
                                visitedCells.add(`${newX},${newY}`);
                                currentDirection = (currentDirection + i) % directions.length;
                                moved = true;
                                break;
                            }
                        }

                        if (!moved) {
                            setTimeout(() => {
                                const next = grid[index(arrowX, arrowY)].checkNeighbors();
                                if (next) {
                                    arrowX = next.x;
                                    arrowY = next.y;
                                    visitedCells.add(`${arrowX},${arrowY}`);
                                }
                            }, 500);
                        }
                    }

                    draw();

                    if (arrowX === cols - 1 && arrowY === rows - 1) {
                        clearInterval(arrowInterval);
                        ctx.fillStyle = 'black';
                        ctx.font = '48px serif';
                        ctx.fillText('ゲームクリア', canvas.width / 2 - 100, canvas.height / 2);
                        ctx.fillText(`チーズ使用回数: ${cheeseCount}`, canvas.width / 2 - 150, canvas.height / 2 + 60);
                    }
                }, 500);
            }

            const interval = setInterval(step, 50);
        }

        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((event.clientX - rect.left) / cellSize);
            const y = Math.floor((event.clientY - rect.top) / cellSize);
            cheese = { x, y };
            cheeseCount++;
            visitedCells.clear();
            moveArrow();
            draw();
        });

        document.getElementById('generateMaze').addEventListener('click', () => {
            clearInterval(arrowInterval);
            arrowX = 0;
            arrowY = 0;
            generateMaze();
        });
    </script>
</body>
</html>
