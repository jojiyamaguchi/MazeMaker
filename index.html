<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>迷路生成</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <button id="generateMaze">新しい迷路を作る</button>
    <canvas id="mazeCanvas" width="500" height="500"></canvas>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const cellSize = 20;
        const cols = canvas.width / cellSize;
        const rows = canvas.height / cellSize;

        function generateMaze() {
            const grid = [];
            const stack = [];
            let current;

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    grid.push(new Cell(x, y));
                }
            }

            current = grid[0];
            current.visited = true;

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let i = 0; i < grid.length; i++) {
                    grid[i].show();
                }
                drawStartAndGoal();
            }

            function Cell(x, y) {
                this.x = x;
                this.y = y;
                this.walls = [true, true, true, true]; // top, right, bottom, left
                this.visited = false;

                this.show = function() {
                    const x = this.x * cellSize;
                    const y = this.y * cellSize;
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;

                    if (this.walls[0]) ctx.strokeRect(x, y, cellSize, 0); // top
                    if (this.walls[1]) ctx.strokeRect(x + cellSize, y, 0, cellSize); // right
                    if (this.walls[2]) ctx.strokeRect(x, y + cellSize, cellSize, 0); // bottom
                    if (this.walls[3]) ctx.strokeRect(x, y, 0, cellSize); // left

                    if (this.visited) {
                        ctx.fillStyle = 'white';
                        ctx.fillRect(x, y, cellSize, cellSize);
                    }
                };

                this.checkNeighbors = function() {
                    const neighbors = [];
                    const top = grid[index(this.x, this.y - 1)];
                    const right = grid[index(this.x + 1, this.y)];
                    const bottom = grid[index(this.x, this.y + 1)];
                    const left = grid[index(this.x - 1, this.y)];

                    if (top && !top.visited) neighbors.push(top);
                    if (right && !right.visited) neighbors.push(right);
                    if (bottom && !bottom.visited) neighbors.push(bottom);
                    if (left && !left.visited) neighbors.push(left);

                    if (neighbors.length > 0) {
                        const r = Math.floor(Math.random() * neighbors.length);
                        return neighbors[r];
                    } else {
                        return undefined;
                    }
                };
            }

            function index(x, y) {
                if (x < 0 || y < 0 || x >= cols || y >= rows) {
                    return -1;
                }
                return x + y * cols;
            }

            function removeWalls(a, b) {
                const x = a.x - b.x;
                if (x === 1) {
                    a.walls[3] = false;
                    b.walls[1] = false;
                } else if (x === -1) {
                    a.walls[1] = false;
                    b.walls[3] = false;
                }
                const y = a.y - b.y;
                if (y === 1) {
                    a.walls[0] = false;
                    b.walls[2] = false;
                } else if (y === -1) {
                    a.walls[2] = false;
                    b.walls[0] = false;
                }
            }

            function step() {
                draw();
                const next = current.checkNeighbors();
                if (next) {
                    next.visited = true;
                    stack.push(current);
                    removeWalls(current, next);
                    current = next;
                } else if (stack.length > 0) {
                    current = stack.pop();
                } else {
                    clearInterval(interval);
                }
            }

            function drawStartAndGoal() {
                // Draw start
                ctx.fillStyle = 'green';
                ctx.fillRect(0, 0, cellSize, cellSize);

                // Draw goal
                ctx.fillStyle = 'red';
                ctx.fillRect((cols - 1) * cellSize, (rows - 1) * cellSize, cellSize, cellSize);
            }

            const interval = setInterval(step, 50);
        }

        document.getElementById('generateMaze').addEventListener('click', generateMaze);
    </script>
</body>
</html>
